# Digital Mock-Up in PowerPoint

In this example the menu [menuInfographics6.pptx](https://github.com/nilostolte/MicroVBA-PowerPoint/blob/main/menuInfographics6.pptx), which was converted from Java to MicroVBA ([macro.txt](https://github.com/nilostolte/MicroVBA-PowerPoint/blob/main/MicroVBA%20Interpreter/macro.txt)) and then imported in PowerPoint using the [MicroVBA interpreter](https://github.com/nilostolte/MicroVBA-PowerPoint/blob/main/MicroVBA%20Interpreter/ReadMicroVBA.pptm), is used to simulate the menu behavior. This is ideal to be used as a **digital mock-up** before delivering the program.

## Protecting a Design with Automatic Watermark
Once inside PowerPoint the design cannot be correctly converted to other vector formats from PowerPoint. This is a desirable feature coming from the fact that Microsoft actually hides how it really handles its objects internally. Thus, it can function as a kind of watermark. Thanks to this feature, objects once imported into PowerPoint cannot be copied to automatically generate the interface from it. It is an ideal way to present a product (either in the case of a design or an interface object, as in this menu) remotely without the danger of having the design copied. 

### The Hidden Side of PowerPoint Objects
Many details on how Microsoft manages PowerPoint objects are hidden even from VBA macros. An example of this is how subpaths are managed, since "moveto" commands are not available to users to add nodes using the **BuildFreeform**. This problem is shown in [Understanding PowerPoint Internal Path Representation](https://github.com/nilostolte/MicroVBA-PowerPoint/blob/main/README.md#understanding-powerpoint-internal-path-representation). Actually this title should have been _"How to create subpaths even though commands to create them are clearly missing"_. 
Therefore, the technique presented in [Contructing Paths in PowerPoint](https://github.com/nilostolte/MicroVBA-PowerPoint/blob/main/README.md#contructing-paths-in-powerpoint) is actually a hack to bypass this problem. Fortunately this hack and the properties unavailable to VBA play in our favor to avoid having the design copied. Obviously, it still can be hacked, provided the hacker is aware of the fact that the hack we used actualy allows distinguishing the different subpaths inside the path and _"decoding"_ them back to something everyone can understand. But that is maybe not worth the time of doing it.

Another example of hidden features are texts formatted inside _"TextBoxes"_. Examining these objects with VBA debugger unveils the mystery on how Microsoft handles fonts and other formatting features such as words with different font sizes in a string. It offers a way to set the fonts in _"TextBoxes"_ using VBA but not how to read them when they are created in Powerpoint. In reality, when one creates a _"TextBox"_ in PowerPoint, the "Font Name" field will remain empty even after creating the _"TextBox"_ with a text typed in. 
Obviously there must be some sort of formatted string language that does not appear to the user in VBA and that is apparently not documented. This clearly prevent users to copy this information from PowerPoint. One will notice that the only thing accessible to the user in VBA in this case is the string itself without any formatting or fonts 

#### Programming, Scripting And Macro Languages
If one just take the example of a formatted text in a _"TextBox"_, one will quickly realize that there is apparently no way to create the same formatted string in VBA programmatically, expept mimicking what is done by hand, step by step. One can see here one of the differences between a programming language, a script language and a macro language. VBA in PowerPoint is apparently situated somewhere between a script and a macro language. Nobody doubts about the power of the language itself, but when important features of the application are hidden from the language it is clearly delegated at a lower category. However, VBA is so powerful that it is possible to construct real programs in PowerPoint, but sometimes to have certain features it is far easier to create the objects exhibiting the desired features by hand in the application and afterwards using the object than creating the feature in VBA. The reason of that is that one needs to program every step for creating the feature manually. This is clearly counterproductive, cumbersome and awkward, unless one is trying to create hundred of similar objects, the typical case of the use of a macro. 
But in PowerPoint it is not even possible to mimick user step by step. Clearly, Microsoft didn't intend VBA to be considered as a serious programming language in PowerPoint and that is maybe the reason why VBA programs are refered as "macros". Many programs in Excel, for example, cannot be classified as macros. But Excel VBA has many advanced features that PowerPoint lacks. 

#### The Lack of Features in Path Creation
One can see the same problem when one wants to create paths with subpaths automatically using **BuildFreeform**. This is the only way to explicitly create heterogeneous paths in PowerPoint using VBA. For simple paths there are no problems (similarly to the case of the formatted texts above), but when one wants to create complex paths with subpaths, one needs to either use a hack (as shown in [Contructing Paths in PowerPoint](https://github.com/nilostolte/MicroVBA-PowerPoint/blob/main/README.md#contructing-paths-in-powerpoint)), or to mimick user steps in **Combine Shapes** (aka **Merge Shapes**) menu (a fairly obscure and usually hidden command in PowerPoint) to add (_"Union"_ operation), subtract (_"Subtract"_ operation), intersect (_"Intersect"_ operation) or to do an _"exclusive or"_ (_"Combine"_ operation) with two objects. One certainly has more possibilities with **Combine Shapes** than with simply appending or subtracting subpaths. An _"Union"_ or an _"Intersection"_, for example, between two shapes are much more powerful operations, but these operations cannot be done directly in VBA 2010. 

It seems that the feature appeared in 2017 as a method of **ShapeRange** object. The method is called [_"MergeShapes"_](https://docs.microsoft.com/en-us/office/vba/api/powerpoint.shaperange.mergeshapes) and apparently it provides the desired effect of combining two or more shapes using the operation passed as a parameter. The meaning of the parameter is described by the enum [**MsoMergeCmd**](https://docs.microsoft.com/en-us/dotnet/api/microsoft.office.core.msomergecmd). 

This is a very interesting upgrade, even though ShapeRange collections are created using the Range method of Shapes object, that has a bit [awkward interface](https://docs.microsoft.com/en-us/office/vba/api/powerpoint.shaperange). 

Therefore, if one has a version of PowerPoint that supports [_"MergeShapes"_](https://docs.microsoft.com/en-us/office/vba/api/powerpoint.shaperange.mergeshapes) one can combine paths in a much more high level way than using the method described in [Contructing Paths in PowerPoint](https://github.com/nilostolte/MicroVBA-PowerPoint/blob/main/README.md#contructing-paths-in-powerpoint), but technically what one is producing is not a path with subpaths but a unique path that combines the different sub paths into just one path. This is equivalent of using the operations of shapes in _"Areas"_ in Java. 
